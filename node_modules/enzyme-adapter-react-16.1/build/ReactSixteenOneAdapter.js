"use strict";

var _object = _interopRequireDefault(require("object.assign"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _server = _interopRequireDefault(require("react-dom/server"));

var _shallow = _interopRequireDefault(require("react-test-renderer/shallow"));

var _testUtils = _interopRequireDefault(require("react-dom/test-utils"));

var _checkPropTypes2 = _interopRequireDefault(require("prop-types/checkPropTypes"));

var _reactIs = require("react-is");

var _enzyme = require("enzyme");

var _enzymeAdapterUtils = require("enzyme-adapter-utils");

var _reflection = require("react-reconciler/reflection");

var _displayNamesByType;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var HostRoot = 3;
var ClassComponent = 2;
var FunctionalComponent = 1;
var HostPortal = 4;
var HostComponent = 5;
var HostText = 6;
var FragmentType = 10;
var Mode = 11;

function nodeAndSiblingsArray(nodeWithSibling) {
  var array = [];
  var node = nodeWithSibling;

  while (node != null) {
    array.push(node);
    node = node.sibling;
  }

  return array;
}

var displayNamesByType = (_displayNamesByType = {}, _defineProperty(_displayNamesByType, _reactIs.Fragment, 'Fragment'), _defineProperty(_displayNamesByType, _reactIs.Portal, 'Portal'), _displayNamesByType);

function flatten(arr) {
  var result = [];
  var stack = [{
    i: 0,
    array: arr
  }];

  while (stack.length) {
    var n = stack.pop();

    while (n.i < n.array.length) {
      var el = n.array[n.i];
      n.i += 1;

      if (Array.isArray(el)) {
        stack.push(n);
        stack.push({
          i: 0,
          array: el
        });
        break;
      }

      result.push(el);
    }
  }

  return result;
}

function nodeTypeFromType(type) {
  if (type === _reactIs.Portal) {
    return 'portal';
  }

  return (0, _enzymeAdapterUtils.nodeTypeFromType)(type);
}

function elementToTree(el) {
  if (!(0, _reactIs.isPortal)(el)) {
    return (0, _enzymeAdapterUtils.elementToTree)(el, elementToTree);
  }

  var children = el.children,
      containerInfo = el.containerInfo;
  var props = {
    children: children,
    containerInfo: containerInfo
  };
  return {
    nodeType: 'portal',
    type: _reactIs.Portal,
    props: props,
    key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(el.key),
    ref: el.ref || null,
    instance: null,
    rendered: elementToTree(el.children)
  };
}

function _toTree(vnode) {
  if (vnode == null) {
    return null;
  } // TODO(lmr): I'm not really sure I understand whether or not this is what
  // i should be doing, or if this is a hack for something i'm doing wrong
  // somewhere else. Should talk to sebastian about this perhaps


  var node = (0, _reflection.findCurrentFiberUsingSlowPath)(vnode);

  switch (node.tag) {
    case HostRoot:
      // 3
      return childrenToTree(node.child);

    case HostPortal:
      {
        // 4
        var containerInfo = node.stateNode.containerInfo,
            children = node.memoizedProps;
        var props = {
          containerInfo: containerInfo,
          children: children
        };
        return {
          nodeType: 'portal',
          type: _reactIs.Portal,
          props: props,
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: childrenToTree(node.child)
        };
      }

    case ClassComponent:
      return {
        nodeType: 'class',
        type: node.type,
        props: _objectSpread({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: node.stateNode,
        rendered: childrenToTree(node.child)
      };

    case FunctionalComponent:
      // 1
      return {
        nodeType: 'function',
        type: node.type,
        props: _objectSpread({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: null,
        rendered: childrenToTree(node.child)
      };

    case HostComponent:
      {
        // 5
        var renderedNodes = flatten(nodeAndSiblingsArray(node.child).map(_toTree));

        if (renderedNodes.length === 0) {
          renderedNodes = [node.memoizedProps.children];
        }

        return {
          nodeType: 'host',
          type: node.type,
          props: _objectSpread({}, node.memoizedProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: node.stateNode,
          rendered: renderedNodes
        };
      }

    case HostText:
      // 6
      return node.memoizedProps;

    case FragmentType: // 10

    case Mode:
      // 11
      return childrenToTree(node.child);

    default:
      throw new Error("Enzyme Internal Error: unknown node with tag ".concat(node.tag));
  }
}

function childrenToTree(node) {
  if (!node) {
    return null;
  }

  var children = nodeAndSiblingsArray(node);

  if (children.length === 0) {
    return null;
  }

  if (children.length === 1) {
    return _toTree(children[0]);
  }

  return flatten(children.map(_toTree));
}

function _nodeToHostNode(_node) {
  // NOTE(lmr): node could be a function component
  // which wont have an instance prop, but we can get the
  // host node associated with its return value at that point.
  // Although this breaks down if the return value is an array,
  // as is possible with React 16.
  var node = _node;

  while (node && !Array.isArray(node) && node.instance === null) {
    node = node.rendered;
  } // if the SFC returned null effectively, there is no host node.


  if (!node) {
    return null;
  }

  var mapper = function mapper(item) {
    if (item && item.instance) return _reactDom["default"].findDOMNode(item.instance);
    return null;
  };

  if (Array.isArray(node)) {
    return node.map(mapper);
  }

  if (Array.isArray(node.rendered) && node.nodeType === 'class') {
    return node.rendered.map(mapper);
  }

  return mapper(node);
}

var eventOptions = {
  animation: true
};

function getEmptyStateValue() {
  // this handles a bug in React 16.0 - 16.2
  // see https://github.com/facebook/react/commit/39be83565c65f9c522150e52375167568a2a1459
  // also see https://github.com/facebook/react/pull/11965
  // eslint-disable-next-line react/prefer-stateless-function
  var EmptyState = /*#__PURE__*/function (_React$Component) {
    _inherits(EmptyState, _React$Component);

    var _super = _createSuper(EmptyState);

    function EmptyState() {
      _classCallCheck(this, EmptyState);

      return _super.apply(this, arguments);
    }

    _createClass(EmptyState, [{
      key: "render",
      value: function render() {
        return null;
      }
    }]);

    return EmptyState;
  }(_react["default"].Component);

  var testRenderer = new _shallow["default"]();
  testRenderer.render( /*#__PURE__*/_react["default"].createElement(EmptyState));
  return testRenderer._instance.state;
}

var ReactSixteenOneAdapter = /*#__PURE__*/function (_EnzymeAdapter) {
  _inherits(ReactSixteenOneAdapter, _EnzymeAdapter);

  var _super2 = _createSuper(ReactSixteenOneAdapter);

  function ReactSixteenOneAdapter() {
    var _this;

    _classCallCheck(this, ReactSixteenOneAdapter);

    _this = _super2.call(this);
    var lifecycles = _this.options.lifecycles;
    _this.options = _objectSpread(_objectSpread({}, _this.options), {}, {
      legacyContextMode: 'parent',
      lifecycles: _objectSpread(_objectSpread({}, lifecycles), {}, {
        componentDidUpdate: {
          onSetState: true
        },
        setState: {
          skipsComponentDidUpdateOnNullish: true
        },
        getChildContext: {
          calledByRenderer: false
        }
      })
    });
    return _this;
  }

  _createClass(ReactSixteenOneAdapter, [{
    key: "createMountRenderer",
    value: function createMountRenderer(options) {
      (0, _enzymeAdapterUtils.assertDomAvailable)('mount');
      var attachTo = options.attachTo,
          hydrateIn = options.hydrateIn,
          wrappingComponentProps = options.wrappingComponentProps;
      var domNode = hydrateIn || attachTo || global.document.createElement('div');
      var instance = null;
      var adapter = this;
      return {
        render: function render(el, context, callback) {
          if (instance === null) {
            var type = el.type,
                props = el.props,
                ref = el.ref;

            var wrapperProps = _objectSpread({
              Component: type,
              props: props,
              wrappingComponentProps: wrappingComponentProps,
              context: context
            }, ref && {
              refProp: ref
            });

            var ReactWrapperComponent = (0, _enzymeAdapterUtils.createMountWrapper)(el, _objectSpread(_objectSpread({}, options), {}, {
              adapter: adapter
            }));

            var wrappedEl = /*#__PURE__*/_react["default"].createElement(ReactWrapperComponent, wrapperProps);

            instance = hydrateIn ? _reactDom["default"].hydrate(wrappedEl, domNode) : _reactDom["default"].render(wrappedEl, domNode);

            if (typeof callback === 'function') {
              callback();
            }
          } else {
            instance.setChildProps(el.props, context, callback);
          }
        },
        unmount: function unmount() {
          _reactDom["default"].unmountComponentAtNode(domNode);

          instance = null;
        },
        getNode: function getNode() {
          if (!instance) {
            return null;
          }

          return (0, _enzymeAdapterUtils.getNodeFromRootFinder)(adapter.isCustomComponent, _toTree(instance._reactInternalFiber), options);
        },
        simulateError: function simulateError(nodeHierarchy, rootNode, error) {
          var _ref = nodeHierarchy.find(function (x) {
            return x.instance && x.instance.componentDidCatch;
          }) || {},
              catchingInstance = _ref.instance;

          (0, _enzymeAdapterUtils.simulateError)(error, catchingInstance, rootNode, nodeHierarchy, nodeTypeFromType, adapter.displayNameOfNode);
        },
        simulateEvent: function simulateEvent(node, event, mock) {
          var mappedEvent = (0, _enzymeAdapterUtils.mapNativeEventNames)(event, eventOptions);
          var eventFn = _testUtils["default"].Simulate[mappedEvent];

          if (!eventFn) {
            throw new TypeError("ReactWrapper::simulate() event '".concat(event, "' does not exist"));
          } // eslint-disable-next-line react/no-find-dom-node


          eventFn(adapter.nodeToHostNode(node), mock);
        },
        batchedUpdates: function batchedUpdates(fn) {
          return fn(); // return ReactDOM.unstable_batchedUpdates(fn);
        },
        getWrappingComponentRenderer: function getWrappingComponentRenderer() {
          return _objectSpread(_objectSpread({}, this), (0, _enzymeAdapterUtils.getWrappingComponentMountRenderer)({
            toTree: function toTree(inst) {
              return _toTree(inst._reactInternalFiber);
            },
            getMountWrapperInstance: function getMountWrapperInstance() {
              return instance;
            }
          }));
        }
      };
    }
  }, {
    key: "createShallowRenderer",
    value: function createShallowRenderer()
    /* options */
    {
      var adapter = this;
      var renderer = new _shallow["default"]();
      var isDOM = false;
      var cachedNode = null;
      return {
        render: function render(el, unmaskedContext) {
          cachedNode = el;
          /* eslint consistent-return: 0 */

          if (typeof el.type === 'string') {
            isDOM = true;
          } else {
            isDOM = false;
            var Component = el.type;
            var isStateful = Component.prototype && (Component.prototype.isReactComponent || Array.isArray(Component.__reactAutoBindPairs) // fallback for createClass components
            );
            var context = (0, _enzymeAdapterUtils.getMaskedContext)(Component.contextTypes, unmaskedContext);

            if (!isStateful && typeof Component === 'function') {
              var wrappedEl = (0, _object["default"])(function () {
                return Component.apply(void 0, arguments);
              }, // eslint-disable-line new-cap
              Component);
              return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                return renderer.render(_objectSpread(_objectSpread({}, el), {}, {
                  type: wrappedEl
                }), context);
              });
            }

            if (isStateful) {
              // fix react bug; see implementation of `getEmptyStateValue`
              var emptyStateValue = getEmptyStateValue();

              if (emptyStateValue) {
                Object.defineProperty(Component.prototype, 'state', {
                  configurable: true,
                  enumerable: true,
                  get: function get() {
                    return null;
                  },
                  set: function set(value) {
                    if (value !== emptyStateValue) {
                      Object.defineProperty(this, 'state', {
                        configurable: true,
                        enumerable: true,
                        value: value,
                        writable: true
                      });
                    }

                    return true;
                  }
                });
              }
            }

            return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
              return renderer.render(el, context);
            });
          }
        },
        unmount: function unmount() {
          renderer.unmount();
        },
        getNode: function getNode() {
          if (isDOM) {
            return elementToTree(cachedNode);
          }

          var output = renderer.getRenderOutput();
          return {
            nodeType: nodeTypeFromType(cachedNode.type),
            type: cachedNode.type,
            props: cachedNode.props,
            key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(cachedNode.key),
            ref: cachedNode.ref,
            instance: renderer._instance,
            rendered: Array.isArray(output) ? flatten(output).map(function (el) {
              return elementToTree(el);
            }) : elementToTree(output)
          };
        },
        simulateError: function simulateError(nodeHierarchy, rootNode, error) {
          (0, _enzymeAdapterUtils.simulateError)(error, renderer._instance, cachedNode, nodeHierarchy.concat(cachedNode), nodeTypeFromType, adapter.displayNameOfNode);
        },
        simulateEvent: function simulateEvent(node, event) {
          for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }

          var handler = node.props[(0, _enzymeAdapterUtils.propFromEvent)(event, eventOptions)];

          if (handler) {
            (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
              // TODO(lmr): create/use synthetic events
              // TODO(lmr): emulate React's event propagation
              // ReactDOM.unstable_batchedUpdates(() => {
              handler.apply(void 0, args); // });
            });
          }
        },
        batchedUpdates: function batchedUpdates(fn) {
          return fn(); // return ReactDOM.unstable_batchedUpdates(fn);
        },
        checkPropTypes: function checkPropTypes(typeSpecs, values, location, hierarchy) {
          return (0, _checkPropTypes2["default"])(typeSpecs, values, location, (0, _enzymeAdapterUtils.displayNameOfNode)(cachedNode), function () {
            return (0, _enzymeAdapterUtils.getComponentStack)(hierarchy.concat([cachedNode]));
          });
        }
      };
    }
  }, {
    key: "createStringRenderer",
    value: function createStringRenderer(options) {
      return {
        render: function render(el, context) {
          if (options.context && (el.type.contextTypes || options.childContextTypes)) {
            var childContextTypes = _objectSpread(_objectSpread({}, el.type.contextTypes || {}), options.childContextTypes);

            var ContextWrapper = (0, _enzymeAdapterUtils.createRenderWrapper)(el, context, childContextTypes);
            return _server["default"].renderToStaticMarkup( /*#__PURE__*/_react["default"].createElement(ContextWrapper));
          }

          return _server["default"].renderToStaticMarkup(el);
        }
      };
    } // Provided a bag of options, return an `EnzymeRenderer`. Some options can be implementation
    // specific, like `attach` etc. for React, but not part of this interface explicitly.
    // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "createRenderer",
    value: function createRenderer(options) {
      switch (options.mode) {
        case _enzyme.EnzymeAdapter.MODES.MOUNT:
          return this.createMountRenderer(options);

        case _enzyme.EnzymeAdapter.MODES.SHALLOW:
          return this.createShallowRenderer(options);

        case _enzyme.EnzymeAdapter.MODES.STRING:
          return this.createStringRenderer(options);

        default:
          throw new Error("Enzyme Internal Error: Unrecognized mode: ".concat(options.mode));
      }
    }
  }, {
    key: "wrap",
    value: function wrap(element) {
      return (0, _enzymeAdapterUtils.wrap)(element);
    } // converts an RSTNode to the corresponding JSX Pragma Element. This will be needed
    // in order to implement the `Wrapper.mount()` and `Wrapper.shallow()` methods, but should
    // be pretty straightforward for people to implement.
    // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "nodeToElement",
    value: function nodeToElement(node) {
      if (!node || _typeof(node) !== 'object') return null;
      return /*#__PURE__*/_react["default"].createElement(node.type, (0, _enzymeAdapterUtils.propsWithKeysAndRef)(node));
    }
  }, {
    key: "elementToNode",
    value: function elementToNode(element) {
      return elementToTree(element);
    }
  }, {
    key: "nodeToHostNode",
    value: function nodeToHostNode(node) {
      var supportsArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var nodes = _nodeToHostNode(node);

      if (Array.isArray(nodes) && !supportsArray) {
        return nodes[0];
      }

      return nodes;
    }
  }, {
    key: "displayNameOfNode",
    value: function displayNameOfNode(node) {
      if (!node) return null;
      var type = node.type,
          $$typeof = node.$$typeof;
      return displayNamesByType[type || $$typeof] || (0, _enzymeAdapterUtils.displayNameOfNode)(node);
    }
  }, {
    key: "isValidElement",
    value: function isValidElement(element) {
      return (0, _reactIs.isElement)(element);
    }
  }, {
    key: "isValidElementType",
    value: function isValidElementType(object) {
      return (0, _reactIs.isValidElementType)(object);
    }
  }, {
    key: "isCustomComponent",
    value: function isCustomComponent(component) {
      return typeof component === 'function';
    }
  }, {
    key: "createElement",
    value: function createElement() {
      return /*#__PURE__*/_react["default"].createElement.apply(_react["default"], arguments);
    }
  }, {
    key: "wrapWithWrappingComponent",
    value: function wrapWithWrappingComponent(node, options) {
      return {
        RootFinder: _enzymeAdapterUtils.RootFinder,
        node: (0, _enzymeAdapterUtils.wrapWithWrappingComponent)(_react["default"].createElement, node, options)
      };
    }
  }]);

  return ReactSixteenOneAdapter;
}(_enzyme.EnzymeAdapter);

module.exports = ReactSixteenOneAdapter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9SZWFjdFNpeHRlZW5PbmVBZGFwdGVyLmpzIl0sIm5hbWVzIjpbIkhvc3RSb290IiwiQ2xhc3NDb21wb25lbnQiLCJGdW5jdGlvbmFsQ29tcG9uZW50IiwiSG9zdFBvcnRhbCIsIkhvc3RDb21wb25lbnQiLCJIb3N0VGV4dCIsIkZyYWdtZW50VHlwZSIsIk1vZGUiLCJub2RlQW5kU2libGluZ3NBcnJheSIsIm5vZGVXaXRoU2libGluZyIsImFycmF5Iiwibm9kZSIsInB1c2giLCJzaWJsaW5nIiwiZGlzcGxheU5hbWVzQnlUeXBlIiwiRnJhZ21lbnQiLCJQb3J0YWwiLCJmbGF0dGVuIiwiYXJyIiwicmVzdWx0Iiwic3RhY2siLCJpIiwibGVuZ3RoIiwibiIsInBvcCIsImVsIiwiQXJyYXkiLCJpc0FycmF5Iiwibm9kZVR5cGVGcm9tVHlwZSIsInR5cGUiLCJlbGVtZW50VG9UcmVlIiwiY2hpbGRyZW4iLCJjb250YWluZXJJbmZvIiwicHJvcHMiLCJub2RlVHlwZSIsImtleSIsInJlZiIsImluc3RhbmNlIiwicmVuZGVyZWQiLCJ0b1RyZWUiLCJ2bm9kZSIsInRhZyIsImNoaWxkcmVuVG9UcmVlIiwiY2hpbGQiLCJzdGF0ZU5vZGUiLCJtZW1vaXplZFByb3BzIiwicmVuZGVyZWROb2RlcyIsIm1hcCIsIkVycm9yIiwibm9kZVRvSG9zdE5vZGUiLCJfbm9kZSIsIm1hcHBlciIsIml0ZW0iLCJSZWFjdERPTSIsImZpbmRET01Ob2RlIiwiZXZlbnRPcHRpb25zIiwiYW5pbWF0aW9uIiwiZ2V0RW1wdHlTdGF0ZVZhbHVlIiwiRW1wdHlTdGF0ZSIsIlJlYWN0IiwiQ29tcG9uZW50IiwidGVzdFJlbmRlcmVyIiwiU2hhbGxvd1JlbmRlcmVyIiwicmVuZGVyIiwiY3JlYXRlRWxlbWVudCIsIl9pbnN0YW5jZSIsInN0YXRlIiwiUmVhY3RTaXh0ZWVuT25lQWRhcHRlciIsImxpZmVjeWNsZXMiLCJvcHRpb25zIiwibGVnYWN5Q29udGV4dE1vZGUiLCJjb21wb25lbnREaWRVcGRhdGUiLCJvblNldFN0YXRlIiwic2V0U3RhdGUiLCJza2lwc0NvbXBvbmVudERpZFVwZGF0ZU9uTnVsbGlzaCIsImdldENoaWxkQ29udGV4dCIsImNhbGxlZEJ5UmVuZGVyZXIiLCJhdHRhY2hUbyIsImh5ZHJhdGVJbiIsIndyYXBwaW5nQ29tcG9uZW50UHJvcHMiLCJkb21Ob2RlIiwiZ2xvYmFsIiwiZG9jdW1lbnQiLCJhZGFwdGVyIiwiY29udGV4dCIsImNhbGxiYWNrIiwid3JhcHBlclByb3BzIiwicmVmUHJvcCIsIlJlYWN0V3JhcHBlckNvbXBvbmVudCIsIndyYXBwZWRFbCIsImh5ZHJhdGUiLCJzZXRDaGlsZFByb3BzIiwidW5tb3VudCIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJnZXROb2RlIiwiaXNDdXN0b21Db21wb25lbnQiLCJfcmVhY3RJbnRlcm5hbEZpYmVyIiwic2ltdWxhdGVFcnJvciIsIm5vZGVIaWVyYXJjaHkiLCJyb290Tm9kZSIsImVycm9yIiwiZmluZCIsIngiLCJjb21wb25lbnREaWRDYXRjaCIsImNhdGNoaW5nSW5zdGFuY2UiLCJkaXNwbGF5TmFtZU9mTm9kZSIsInNpbXVsYXRlRXZlbnQiLCJldmVudCIsIm1vY2siLCJtYXBwZWRFdmVudCIsImV2ZW50Rm4iLCJUZXN0VXRpbHMiLCJTaW11bGF0ZSIsIlR5cGVFcnJvciIsImJhdGNoZWRVcGRhdGVzIiwiZm4iLCJnZXRXcmFwcGluZ0NvbXBvbmVudFJlbmRlcmVyIiwiaW5zdCIsImdldE1vdW50V3JhcHBlckluc3RhbmNlIiwicmVuZGVyZXIiLCJpc0RPTSIsImNhY2hlZE5vZGUiLCJ1bm1hc2tlZENvbnRleHQiLCJpc1N0YXRlZnVsIiwicHJvdG90eXBlIiwiaXNSZWFjdENvbXBvbmVudCIsIl9fcmVhY3RBdXRvQmluZFBhaXJzIiwiY29udGV4dFR5cGVzIiwiZW1wdHlTdGF0ZVZhbHVlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic2V0IiwidmFsdWUiLCJ3cml0YWJsZSIsIm91dHB1dCIsImdldFJlbmRlck91dHB1dCIsImNvbmNhdCIsImFyZ3MiLCJoYW5kbGVyIiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJsb2NhdGlvbiIsImhpZXJhcmNoeSIsImNoaWxkQ29udGV4dFR5cGVzIiwiQ29udGV4dFdyYXBwZXIiLCJSZWFjdERPTVNlcnZlciIsInJlbmRlclRvU3RhdGljTWFya3VwIiwibW9kZSIsIkVuenltZUFkYXB0ZXIiLCJNT0RFUyIsIk1PVU5UIiwiY3JlYXRlTW91bnRSZW5kZXJlciIsIlNIQUxMT1ciLCJjcmVhdGVTaGFsbG93UmVuZGVyZXIiLCJTVFJJTkciLCJjcmVhdGVTdHJpbmdSZW5kZXJlciIsImVsZW1lbnQiLCJzdXBwb3J0c0FycmF5Iiwibm9kZXMiLCIkJHR5cGVvZiIsIm9iamVjdCIsImNvbXBvbmVudCIsIlJvb3RGaW5kZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBT0E7O0FBQ0E7O0FBcUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTUEsUUFBUSxHQUFHLENBQWpCO0FBQ0EsSUFBTUMsY0FBYyxHQUFHLENBQXZCO0FBQ0EsSUFBTUMsbUJBQW1CLEdBQUcsQ0FBNUI7QUFDQSxJQUFNQyxVQUFVLEdBQUcsQ0FBbkI7QUFDQSxJQUFNQyxhQUFhLEdBQUcsQ0FBdEI7QUFDQSxJQUFNQyxRQUFRLEdBQUcsQ0FBakI7QUFDQSxJQUFNQyxZQUFZLEdBQUcsRUFBckI7QUFDQSxJQUFNQyxJQUFJLEdBQUcsRUFBYjs7QUFFQSxTQUFTQyxvQkFBVCxDQUE4QkMsZUFBOUIsRUFBK0M7QUFDN0MsTUFBTUMsS0FBSyxHQUFHLEVBQWQ7QUFDQSxNQUFJQyxJQUFJLEdBQUdGLGVBQVg7O0FBQ0EsU0FBT0UsSUFBSSxJQUFJLElBQWYsRUFBcUI7QUFDbkJE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LEtBQUssR0FBR2pILGVBQWMsQ0FBQ3RDLElBQUQsQ0FBNUI7O0FBQ0EsVUFBSWUsS0FBSyxDQUFDQyxPQUFOLENBQWN1SSxLQUFkLEtBQXdCLENBQUNELGFBQTdCLEVBQTRDO0FBQzFDLGVBQU9DLEtBQUssQ0FBQyxDQUFELENBQVo7QUFDRDs7QUFDRCxhQUFPQSxLQUFQO0FBQ0Q7OztzQ0FFaUJ2SixJLEVBQU07QUFDdEIsVUFBSSxDQUFDQSxJQUFMLEVBQVcsT0FBTyxJQUFQO0FBRFcsVUFHZGtCLElBSGMsR0FHS2xCLElBSEwsQ0FHZGtCLElBSGM7QUFBQSxVQUdSc0ksUUFIUSxHQUdLeEosSUFITCxDQUdSd0osUUFIUTtBQUl0QixhQUFPckosa0JBQWtCLENBQUNlLElBQUksSUFBSXNJLFFBQVQsQ0FBbEIsSUFBd0MsMkNBQWtCeEosSUFBbEIsQ0FBL0M7QUFDRDs7O21DQUVjcUosTyxFQUFTO0FBQ3RCLGFBQU8sd0JBQVVBLE9BQVYsQ0FBUDtBQUNEOzs7dUNBRWtCSSxNLEVBQVE7QUFDekIsYUFBTyxpQ0FBbUJBLE1BQW5CLENBQVA7QUFDRDs7O3NDQUVpQkMsUyxFQUFXO0FBQzNCLGFBQU8sT0FBT0EsU0FBUCxLQUFxQixVQUE1QjtBQUNEOzs7b0NBRXNCO0FBQ3JCLDBCQUFPMUcsa0JBQU1LLGFBQU4sb0NBQVA7QUFDRDs7OzhDQUV5QnJELEksRUFBTTBELE8sRUFBUztBQUN2QyxhQUFPO0FBQ0xpRyxRQUFBQSxVQUFVLEVBQVZBLDhCQURLO0FBRUwzSixRQUFBQSxJQUFJLEVBQUUsbURBQTBCZ0Qsa0JBQU1LLGFBQWhDLEVBQStDckQsSUFBL0MsRUFBcUQwRCxPQUFyRDtBQUZELE9BQVA7QUFJRDs7OztFQTFTa0NtRixxQjs7QUE2U3JDZSxNQUFNLENBQUNDLE9BQVAsR0FBaUJyRyxzQkFBakIiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdXNlLWJlZm9yZS1kZWZpbmU6IDAgKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW5yZXNvbHZlZFxuaW1wb3J0IFJlYWN0RE9NU2VydmVyIGZyb20gJ3JlYWN0LWRvbS9zZXJ2ZXInO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnJlc29sdmVkXG5pbXBvcnQgU2hhbGxvd1JlbmRlcmVyIGZyb20gJ3JlYWN0LXRlc3QtcmVuZGVyZXIvc2hhbGxvdyc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVucmVzb2x2ZWRcbmltcG9ydCBUZXN0VXRpbHMgZnJvbSAncmVhY3QtZG9tL3Rlc3QtdXRpbHMnO1xuaW1wb3J0IGNoZWNrUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnO1xuaW1wb3J0IHtcbiAgaXNFbGVtZW50LFxuICBpc1BvcnRhbCxcbiAgaXNWYWxpZEVsZW1lbnRUeXBlLFxuICBGcmFnbWVudCxcbiAgUG9ydGFsLFxufSBmcm9tICdyZWFjdC1pcyc7XG5pbXBvcnQgeyBFbnp5bWVBZGFwdGVyIH0gZnJvbSAnZW56eW1lJztcbmltcG9ydCB7XG4gIGRpc3BsYXlOYW1lT2ZOb2RlLFxuICBlbGVtZW50VG9UcmVlIGFzIHV0aWxFbGVtZW50VG9UcmVlLFxuICBub2RlVHlwZUZyb21UeXBlIGFzIHV0aWxOb2RlVHlwZUZyb21UeXBlLFxuICBtYXBOYXRpdmVFdmVudE5hbWVzLFxuICBwcm9wRnJvbUV2ZW50LFxuICBhc3NlcnREb21BdmFpbGFibGUsXG4gIHdpdGhTZXRTdGF0ZUFsbG93ZWQsXG4gIGNyZWF0ZVJlbmRlcldyYXBwZXIsXG4gIGNyZWF0ZU1vdW50V3JhcHBlcixcbiAgcHJvcHNXaXRoS2V5c0FuZFJlZixcbiAgZW5zdXJlS2V5T3JVbmRlZmluZWQsXG4gIHNpbXVsYXRlRXJyb3IsXG4gIHdyYXAsXG4gIGdldE1hc2tlZENvbnRleHQsXG4gIGdldENvbXBvbmVudFN0YWNrLFxuICBSb290RmluZGVyLFxuICBnZXROb2RlRnJvbVJvb3RGaW5kZXIsXG4gIHdyYXBXaXRoV3JhcHBpbmdDb21wb25lbnQsXG4gIGdldFdyYXBwaW5nQ29tcG9uZW50TW91bnRSZW5kZXJlcixcbn0gZnJvbSAnZW56eW1lLWFkYXB0ZXItdXRpbHMnO1xuaW1wb3J0IHsgZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGggfSBmcm9tICdyZWFjdC1yZWNvbmNpbGVyL3JlZmxlY3Rpb24nO1xuXG5jb25zdCBIb3N0Um9vdCA9IDM7XG5jb25zdCBDbGFzc0NvbXBvbmVudCA9IDI7XG5jb25zdCBGdW5jdGlvbmFsQ29tcG9uZW50ID0gMTtcbmNvbnN0IEhvc3RQb3J0YWwgPSA0O1xuY29uc3QgSG9zdENvbXBvbmVudCA9IDU7XG5jb25zdCBIb3N0VGV4dCA9IDY7XG5jb25zdCBGcmFnbWVudFR5cGUgPSAxMDtcbmNvbnN0IE1vZGUgPSAxMTtcblxuZnVuY3Rpb24gbm9kZUFuZFNpYmxpbmdzQXJyYXkobm9kZVdpdGhTaWJsaW5nKSB7XG4gIGNvbnN0IGFycmF5ID0gW107XG4gIGxldCBub2RlID0gbm9kZVdpdGhTaWJsaW5nO1xuICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgYXJyYXkucHVzaChub2RlKTtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuY29uc3QgZGlzcGxheU5hbWVzQnlUeXBlID0ge1xuICBbRnJhZ21lbnRdOiAnRnJhZ21lbnQnLFxuICBbUG9ydGFsXTogJ1BvcnRhbCcsXG59O1xuXG5mdW5jdGlvbiBmbGF0dGVuKGFycikge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3Qgc3RhY2sgPSBbeyBpOiAwLCBhcnJheTogYXJyIH1dO1xuICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgY29uc3QgbiA9IHN0YWNrLnBvcCgpO1xuICAgIHdoaWxlIChuLmkgPCBuLmFycmF5Lmxlbmd0aCkge1xuICAgICAgY29uc3QgZWwgPSBuLmFycmF5W24uaV07XG4gICAgICBuLmkgKz0gMTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGVsKSkge1xuICAgICAgICBzdGFjay5wdXNoKG4pO1xuICAgICAgICBzdGFjay5wdXNoKHsgaTogMCwgYXJyYXk6IGVsIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKGVsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbm9kZVR5cGVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09PSBQb3J0YWwpIHtcbiAgICByZXR1cm4gJ3BvcnRhbCc7XG4gIH1cblxuICByZXR1cm4gdXRpbE5vZGVUeXBlRnJvbVR5cGUodHlwZSk7XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRUb1RyZWUoZWwpIHtcbiAgaWYgKCFpc1BvcnRhbChlbCkpIHtcbiAgICByZXR1cm4gdXRpbEVsZW1lbnRUb1RyZWUoZWwsIGVsZW1lbnRUb1RyZWUpO1xuICB9XG5cbiAgY29uc3QgeyBjaGlsZHJlbiwgY29udGFpbmVySW5mbyB9ID0gZWw7XG4gIGNvbnN0IHByb3BzID0geyBjaGlsZHJlbiwgY29udGFpbmVySW5mbyB9O1xuXG4gIHJldHVybiB7XG4gICAgbm9kZVR5cGU6ICdwb3J0YWwnLFxuICAgIHR5cGU6IFBvcnRhbCxcbiAgICBwcm9wcyxcbiAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKGVsLmtleSksXG4gICAgcmVmOiBlbC5yZWYgfHwgbnVsbCxcbiAgICBpbnN0YW5jZTogbnVsbCxcbiAgICByZW5kZXJlZDogZWxlbWVudFRvVHJlZShlbC5jaGlsZHJlbiksXG4gIH07XG59XG5cbmZ1bmN0aW9uIHRvVHJlZSh2bm9kZSkge1xuICBpZiAodm5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIFRPRE8obG1yKTogSSdtIG5vdCByZWFsbHkgc3VyZSBJIHVuZGVyc3RhbmQgd2hldGhlciBvciBub3QgdGhpcyBpcyB3aGF0XG4gIC8vIGkgc2hvdWxkIGJlIGRvaW5nLCBvciBpZiB0aGlzIGlzIGEgaGFjayBmb3Igc29tZXRoaW5nIGknbSBkb2luZyB3cm9uZ1xuICAvLyBzb21ld2hlcmUgZWxzZS4gU2hvdWxkIHRhbGsgdG8gc2ViYXN0aWFuIGFib3V0IHRoaXMgcGVyaGFwc1xuICBjb25zdCBub2RlID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgodm5vZGUpO1xuICBzd2l0Y2ggKG5vZGUudGFnKSB7XG4gICAgY2FzZSBIb3N0Um9vdDogLy8gM1xuICAgICAgcmV0dXJuIGNoaWxkcmVuVG9UcmVlKG5vZGUuY2hpbGQpO1xuICAgIGNhc2UgSG9zdFBvcnRhbDogeyAvLyA0XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0YXRlTm9kZTogeyBjb250YWluZXJJbmZvIH0sXG4gICAgICAgIG1lbW9pemVkUHJvcHM6IGNoaWxkcmVuLFxuICAgICAgfSA9IG5vZGU7XG4gICAgICBjb25zdCBwcm9wcyA9IHsgY29udGFpbmVySW5mbywgY2hpbGRyZW4gfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVUeXBlOiAncG9ydGFsJyxcbiAgICAgICAgdHlwZTogUG9ydGFsLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChub2RlLmtleSksXG4gICAgICAgIHJlZjogbm9kZS5yZWYsXG4gICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICByZW5kZXJlZDogY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCksXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZVR5cGU6ICdjbGFzcycsXG4gICAgICAgIHR5cGU6IG5vZGUudHlwZSxcbiAgICAgICAgcHJvcHM6IHsgLi4ubm9kZS5tZW1vaXplZFByb3BzIH0sXG4gICAgICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQobm9kZS5rZXkpLFxuICAgICAgICByZWY6IG5vZGUucmVmLFxuICAgICAgICBpbnN0YW5jZTogbm9kZS5zdGF0ZU5vZGUsXG4gICAgICAgIHJlbmRlcmVkOiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkKSxcbiAgICAgIH07XG4gICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OiAvLyAxXG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlVHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICBwcm9wczogeyAuLi5ub2RlLm1lbW9pemVkUHJvcHMgfSxcbiAgICAgICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChub2RlLmtleSksXG4gICAgICAgIHJlZjogbm9kZS5yZWYsXG4gICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICByZW5kZXJlZDogY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCksXG4gICAgICB9O1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDogeyAvLyA1XG4gICAgICBsZXQgcmVuZGVyZWROb2RlcyA9IGZsYXR0ZW4obm9kZUFuZFNpYmxpbmdzQXJyYXkobm9kZS5jaGlsZCkubWFwKHRvVHJlZSkpO1xuICAgICAgaWYgKHJlbmRlcmVkTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlbmRlcmVkTm9kZXMgPSBbbm9kZS5tZW1vaXplZFByb3BzLmNoaWxkcmVuXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVUeXBlOiAnaG9zdCcsXG4gICAgICAgIHR5cGU6IG5vZGUudHlwZSxcbiAgICAgICAgcHJvcHM6IHsgLi4ubm9kZS5tZW1vaXplZFByb3BzIH0sXG4gICAgICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQobm9kZS5rZXkpLFxuICAgICAgICByZWY6IG5vZGUucmVmLFxuICAgICAgICBpbnN0YW5jZTogbm9kZS5zdGF0ZU5vZGUsXG4gICAgICAgIHJlbmRlcmVkOiByZW5kZXJlZE5vZGVzLFxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBIb3N0VGV4dDogLy8gNlxuICAgICAgcmV0dXJuIG5vZGUubWVtb2l6ZWRQcm9wcztcbiAgICBjYXNlIEZyYWdtZW50VHlwZTogLy8gMTBcbiAgICBjYXNlIE1vZGU6IC8vIDExXG4gICAgICByZXR1cm4gY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRW56eW1lIEludGVybmFsIEVycm9yOiB1bmtub3duIG5vZGUgd2l0aCB0YWcgJHtub2RlLnRhZ31gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGlsZHJlblRvVHJlZShub2RlKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZUFuZFNpYmxpbmdzQXJyYXkobm9kZSk7XG4gIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRvVHJlZShjaGlsZHJlblswXSk7XG4gIH1cbiAgcmV0dXJuIGZsYXR0ZW4oY2hpbGRyZW4ubWFwKHRvVHJlZSkpO1xufVxuXG5mdW5jdGlvbiBub2RlVG9Ib3N0Tm9kZShfbm9kZSkge1xuICAvLyBOT1RFKGxtcik6IG5vZGUgY291bGQgYmUgYSBmdW5jdGlvbiBjb21wb25lbnRcbiAgLy8gd2hpY2ggd29udCBoYXZlIGFuIGluc3RhbmNlIHByb3AsIGJ1dCB3ZSBjYW4gZ2V0IHRoZVxuICAvLyBob3N0IG5vZGUgYXNzb2NpYXRlZCB3aXRoIGl0cyByZXR1cm4gdmFsdWUgYXQgdGhhdCBwb2ludC5cbiAgLy8gQWx0aG91Z2ggdGhpcyBicmVha3MgZG93biBpZiB0aGUgcmV0dXJuIHZhbHVlIGlzIGFuIGFycmF5LFxuICAvLyBhcyBpcyBwb3NzaWJsZSB3aXRoIFJlYWN0IDE2LlxuICBsZXQgbm9kZSA9IF9ub2RlO1xuICB3aGlsZSAobm9kZSAmJiAhQXJyYXkuaXNBcnJheShub2RlKSAmJiBub2RlLmluc3RhbmNlID09PSBudWxsKSB7XG4gICAgbm9kZSA9IG5vZGUucmVuZGVyZWQ7XG4gIH1cbiAgLy8gaWYgdGhlIFNGQyByZXR1cm5lZCBudWxsIGVmZmVjdGl2ZWx5LCB0aGVyZSBpcyBubyBob3N0IG5vZGUuXG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgbWFwcGVyID0gKGl0ZW0pID0+IHtcbiAgICBpZiAoaXRlbSAmJiBpdGVtLmluc3RhbmNlKSByZXR1cm4gUmVhY3RET00uZmluZERPTU5vZGUoaXRlbS5pbnN0YW5jZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUubWFwKG1hcHBlcik7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZS5yZW5kZXJlZCkgJiYgbm9kZS5ub2RlVHlwZSA9PT0gJ2NsYXNzJykge1xuICAgIHJldHVybiBub2RlLnJlbmRlcmVkLm1hcChtYXBwZXIpO1xuICB9XG4gIHJldHVybiBtYXBwZXIobm9kZSk7XG59XG5cbmNvbnN0IGV2ZW50T3B0aW9ucyA9IHsgYW5pbWF0aW9uOiB0cnVlIH07XG5cbmZ1bmN0aW9uIGdldEVtcHR5U3RhdGVWYWx1ZSgpIHtcbiAgLy8gdGhpcyBoYW5kbGVzIGEgYnVnIGluIFJlYWN0IDE2LjAgLSAxNi4yXG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvY29tbWl0LzM5YmU4MzU2NWM2NWY5YzUyMjE1MGU1MjM3NTE2NzU2OGEyYTE0NTlcbiAgLy8gYWxzbyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTE5NjVcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvcHJlZmVyLXN0YXRlbGVzcy1mdW5jdGlvblxuICBjbGFzcyBFbXB0eVN0YXRlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgY29uc3QgdGVzdFJlbmRlcmVyID0gbmV3IFNoYWxsb3dSZW5kZXJlcigpO1xuICB0ZXN0UmVuZGVyZXIucmVuZGVyKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRW1wdHlTdGF0ZSkpO1xuICByZXR1cm4gdGVzdFJlbmRlcmVyLl9pbnN0YW5jZS5zdGF0ZTtcbn1cblxuY2xhc3MgUmVhY3RTaXh0ZWVuT25lQWRhcHRlciBleHRlbmRzIEVuenltZUFkYXB0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHsgbGlmZWN5Y2xlcyB9ID0gdGhpcy5vcHRpb25zO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIGxlZ2FjeUNvbnRleHRNb2RlOiAncGFyZW50JyxcbiAgICAgIGxpZmVjeWNsZXM6IHtcbiAgICAgICAgLi4ubGlmZWN5Y2xlcyxcbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlOiB7XG4gICAgICAgICAgb25TZXRTdGF0ZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgc2V0U3RhdGU6IHtcbiAgICAgICAgICBza2lwc0NvbXBvbmVudERpZFVwZGF0ZU9uTnVsbGlzaDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q2hpbGRDb250ZXh0OiB7XG4gICAgICAgICAgY2FsbGVkQnlSZW5kZXJlcjogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBjcmVhdGVNb3VudFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICBhc3NlcnREb21BdmFpbGFibGUoJ21vdW50Jyk7XG4gICAgY29uc3QgeyBhdHRhY2hUbywgaHlkcmF0ZUluLCB3cmFwcGluZ0NvbXBvbmVudFByb3BzIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGRvbU5vZGUgPSBoeWRyYXRlSW4gfHwgYXR0YWNoVG8gfHwgZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxldCBpbnN0YW5jZSA9IG51bGw7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbmRlcihlbCwgY29udGV4dCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGluc3RhbmNlID09PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcywgcmVmIH0gPSBlbDtcbiAgICAgICAgICBjb25zdCB3cmFwcGVyUHJvcHMgPSB7XG4gICAgICAgICAgICBDb21wb25lbnQ6IHR5cGUsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHdyYXBwaW5nQ29tcG9uZW50UHJvcHMsXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgLi4uKHJlZiAmJiB7IHJlZlByb3A6IHJlZiB9KSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IFJlYWN0V3JhcHBlckNvbXBvbmVudCA9IGNyZWF0ZU1vdW50V3JhcHBlcihlbCwgeyAuLi5vcHRpb25zLCBhZGFwdGVyIH0pO1xuICAgICAgICAgIGNvbnN0IHdyYXBwZWRFbCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3RXcmFwcGVyQ29tcG9uZW50LCB3cmFwcGVyUHJvcHMpO1xuICAgICAgICAgIGluc3RhbmNlID0gaHlkcmF0ZUluXG4gICAgICAgICAgICA/IFJlYWN0RE9NLmh5ZHJhdGUod3JhcHBlZEVsLCBkb21Ob2RlKVxuICAgICAgICAgICAgOiBSZWFjdERPTS5yZW5kZXIod3JhcHBlZEVsLCBkb21Ob2RlKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnN0YW5jZS5zZXRDaGlsZFByb3BzKGVsLnByb3BzLCBjb250ZXh0LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1bm1vdW50KCkge1xuICAgICAgICBSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlKGRvbU5vZGUpO1xuICAgICAgICBpbnN0YW5jZSA9IG51bGw7XG4gICAgICB9LFxuICAgICAgZ2V0Tm9kZSgpIHtcbiAgICAgICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXROb2RlRnJvbVJvb3RGaW5kZXIoXG4gICAgICAgICAgYWRhcHRlci5pc0N1c3RvbUNvbXBvbmVudCxcbiAgICAgICAgICB0b1RyZWUoaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxGaWJlciksXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBzaW11bGF0ZUVycm9yKG5vZGVIaWVyYXJjaHksIHJvb3ROb2RlLCBlcnJvcikge1xuICAgICAgICBjb25zdCB7IGluc3RhbmNlOiBjYXRjaGluZ0luc3RhbmNlIH0gPSBub2RlSGllcmFyY2h5XG4gICAgICAgICAgLmZpbmQoKHgpID0+IHguaW5zdGFuY2UgJiYgeC5pbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCkgfHwge307XG5cbiAgICAgICAgc2ltdWxhdGVFcnJvcihcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBjYXRjaGluZ0luc3RhbmNlLFxuICAgICAgICAgIHJvb3ROb2RlLFxuICAgICAgICAgIG5vZGVIaWVyYXJjaHksXG4gICAgICAgICAgbm9kZVR5cGVGcm9tVHlwZSxcbiAgICAgICAgICBhZGFwdGVyLmRpc3BsYXlOYW1lT2ZOb2RlLFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHNpbXVsYXRlRXZlbnQobm9kZSwgZXZlbnQsIG1vY2spIHtcbiAgICAgICAgY29uc3QgbWFwcGVkRXZlbnQgPSBtYXBOYXRpdmVFdmVudE5hbWVzKGV2ZW50LCBldmVudE9wdGlvbnMpO1xuICAgICAgICBjb25zdCBldmVudEZuID0gVGVzdFV0aWxzLlNpbXVsYXRlW21hcHBlZEV2ZW50XTtcbiAgICAgICAgaWYgKCFldmVudEZuKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUmVhY3RXcmFwcGVyOjpzaW11bGF0ZSgpIGV2ZW50ICcke2V2ZW50fScgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tZmluZC1kb20tbm9kZVxuICAgICAgICBldmVudEZuKGFkYXB0ZXIubm9kZVRvSG9zdE5vZGUobm9kZSksIG1vY2spO1xuICAgICAgfSxcbiAgICAgIGJhdGNoZWRVcGRhdGVzKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICAvLyByZXR1cm4gUmVhY3RET00udW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMoZm4pO1xuICAgICAgfSxcbiAgICAgIGdldFdyYXBwaW5nQ29tcG9uZW50UmVuZGVyZXIoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4udGhpcyxcbiAgICAgICAgICAuLi5nZXRXcmFwcGluZ0NvbXBvbmVudE1vdW50UmVuZGVyZXIoe1xuICAgICAgICAgICAgdG9UcmVlOiAoaW5zdCkgPT4gdG9UcmVlKGluc3QuX3JlYWN0SW50ZXJuYWxGaWJlciksXG4gICAgICAgICAgICBnZXRNb3VudFdyYXBwZXJJbnN0YW5jZTogKCkgPT4gaW5zdGFuY2UsXG4gICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBjcmVhdGVTaGFsbG93UmVuZGVyZXIoLyogb3B0aW9ucyAqLykge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IFNoYWxsb3dSZW5kZXJlcigpO1xuICAgIGxldCBpc0RPTSA9IGZhbHNlO1xuICAgIGxldCBjYWNoZWROb2RlID0gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgcmVuZGVyKGVsLCB1bm1hc2tlZENvbnRleHQpIHtcbiAgICAgICAgY2FjaGVkTm9kZSA9IGVsO1xuICAgICAgICAvKiBlc2xpbnQgY29uc2lzdGVudC1yZXR1cm46IDAgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBlbC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlzRE9NID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc0RPTSA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHsgdHlwZTogQ29tcG9uZW50IH0gPSBlbDtcblxuICAgICAgICAgIGNvbnN0IGlzU3RhdGVmdWwgPSBDb21wb25lbnQucHJvdG90eXBlICYmIChcbiAgICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudFxuICAgICAgICAgICAgfHwgQXJyYXkuaXNBcnJheShDb21wb25lbnQuX19yZWFjdEF1dG9CaW5kUGFpcnMpIC8vIGZhbGxiYWNrIGZvciBjcmVhdGVDbGFzcyBjb21wb25lbnRzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dChDb21wb25lbnQuY29udGV4dFR5cGVzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKCFpc1N0YXRlZnVsICYmIHR5cGVvZiBDb21wb25lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZWRFbCA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgICguLi5hcmdzKSA9PiBDb21wb25lbnQoLi4uYXJncyksIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHdpdGhTZXRTdGF0ZUFsbG93ZWQoKCkgPT4gcmVuZGVyZXIucmVuZGVyKHsgLi4uZWwsIHR5cGU6IHdyYXBwZWRFbCB9LCBjb250ZXh0KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1N0YXRlZnVsKSB7XG4gICAgICAgICAgICAvLyBmaXggcmVhY3QgYnVnOyBzZWUgaW1wbGVtZW50YXRpb24gb2YgYGdldEVtcHR5U3RhdGVWYWx1ZWBcbiAgICAgICAgICAgIGNvbnN0IGVtcHR5U3RhdGVWYWx1ZSA9IGdldEVtcHR5U3RhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKGVtcHR5U3RhdGVWYWx1ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgJ3N0YXRlJywge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IGVtcHR5U3RhdGVWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0YXRlJywge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gd2l0aFNldFN0YXRlQWxsb3dlZCgoKSA9PiByZW5kZXJlci5yZW5kZXIoZWwsIGNvbnRleHQpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVubW91bnQoKSB7XG4gICAgICAgIHJlbmRlcmVyLnVubW91bnQoKTtcbiAgICAgIH0sXG4gICAgICBnZXROb2RlKCkge1xuICAgICAgICBpZiAoaXNET00pIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudFRvVHJlZShjYWNoZWROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdXRwdXQgPSByZW5kZXJlci5nZXRSZW5kZXJPdXRwdXQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlVHlwZTogbm9kZVR5cGVGcm9tVHlwZShjYWNoZWROb2RlLnR5cGUpLFxuICAgICAgICAgIHR5cGU6IGNhY2hlZE5vZGUudHlwZSxcbiAgICAgICAgICBwcm9wczogY2FjaGVkTm9kZS5wcm9wcyxcbiAgICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKGNhY2hlZE5vZGUua2V5KSxcbiAgICAgICAgICByZWY6IGNhY2hlZE5vZGUucmVmLFxuICAgICAgICAgIGluc3RhbmNlOiByZW5kZXJlci5faW5zdGFuY2UsXG4gICAgICAgICAgcmVuZGVyZWQ6IEFycmF5LmlzQXJyYXkob3V0cHV0KVxuICAgICAgICAgICAgPyBmbGF0dGVuKG91dHB1dCkubWFwKChlbCkgPT4gZWxlbWVudFRvVHJlZShlbCkpXG4gICAgICAgICAgICA6IGVsZW1lbnRUb1RyZWUob3V0cHV0KSxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBzaW11bGF0ZUVycm9yKG5vZGVIaWVyYXJjaHksIHJvb3ROb2RlLCBlcnJvcikge1xuICAgICAgICBzaW11bGF0ZUVycm9yKFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHJlbmRlcmVyLl9pbnN0YW5jZSxcbiAgICAgICAgICBjYWNoZWROb2RlLFxuICAgICAgICAgIG5vZGVIaWVyYXJjaHkuY29uY2F0KGNhY2hlZE5vZGUpLFxuICAgICAgICAgIG5vZGVUeXBlRnJvbVR5cGUsXG4gICAgICAgICAgYWRhcHRlci5kaXNwbGF5TmFtZU9mTm9kZSxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBzaW11bGF0ZUV2ZW50KG5vZGUsIGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBub2RlLnByb3BzW3Byb3BGcm9tRXZlbnQoZXZlbnQsIGV2ZW50T3B0aW9ucyldO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIHdpdGhTZXRTdGF0ZUFsbG93ZWQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gVE9ETyhsbXIpOiBjcmVhdGUvdXNlIHN5bnRoZXRpYyBldmVudHNcbiAgICAgICAgICAgIC8vIFRPRE8obG1yKTogZW11bGF0ZSBSZWFjdCdzIGV2ZW50IHByb3BhZ2F0aW9uXG4gICAgICAgICAgICAvLyBSZWFjdERPTS51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVyKC4uLmFyZ3MpO1xuICAgICAgICAgICAgLy8gfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBiYXRjaGVkVXBkYXRlcyhmbikge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgLy8gcmV0dXJuIFJlYWN0RE9NLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKGZuKTtcbiAgICAgIH0sXG4gICAgICBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGhpZXJhcmNoeSkge1xuICAgICAgICByZXR1cm4gY2hlY2tQcm9wVHlwZXMoXG4gICAgICAgICAgdHlwZVNwZWNzLFxuICAgICAgICAgIHZhbHVlcyxcbiAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICBkaXNwbGF5TmFtZU9mTm9kZShjYWNoZWROb2RlKSxcbiAgICAgICAgICAoKSA9PiBnZXRDb21wb25lbnRTdGFjayhoaWVyYXJjaHkuY29uY2F0KFtjYWNoZWROb2RlXSkpLFxuICAgICAgICApO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgY3JlYXRlU3RyaW5nUmVuZGVyZXIob3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICByZW5kZXIoZWwsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29udGV4dCAmJiAoZWwudHlwZS5jb250ZXh0VHlwZXMgfHwgb3B0aW9ucy5jaGlsZENvbnRleHRUeXBlcykpIHtcbiAgICAgICAgICBjb25zdCBjaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgICAgIC4uLihlbC50eXBlLmNvbnRleHRUeXBlcyB8fCB7fSksXG4gICAgICAgICAgICAuLi5vcHRpb25zLmNoaWxkQ29udGV4dFR5cGVzLFxuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgQ29udGV4dFdyYXBwZXIgPSBjcmVhdGVSZW5kZXJXcmFwcGVyKGVsLCBjb250ZXh0LCBjaGlsZENvbnRleHRUeXBlcyk7XG4gICAgICAgICAgcmV0dXJuIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RhdGljTWFya3VwKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dFdyYXBwZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdGF0aWNNYXJrdXAoZWwpO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgLy8gUHJvdmlkZWQgYSBiYWcgb2Ygb3B0aW9ucywgcmV0dXJuIGFuIGBFbnp5bWVSZW5kZXJlcmAuIFNvbWUgb3B0aW9ucyBjYW4gYmUgaW1wbGVtZW50YXRpb25cbiAgLy8gc3BlY2lmaWMsIGxpa2UgYGF0dGFjaGAgZXRjLiBmb3IgUmVhY3QsIGJ1dCBub3QgcGFydCBvZiB0aGlzIGludGVyZmFjZSBleHBsaWNpdGx5LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcywgbm8tdW51c2VkLXZhcnNcbiAgY3JlYXRlUmVuZGVyZXIob3B0aW9ucykge1xuICAgIHN3aXRjaCAob3B0aW9ucy5tb2RlKSB7XG4gICAgICBjYXNlIEVuenltZUFkYXB0ZXIuTU9ERVMuTU9VTlQ6IHJldHVybiB0aGlzLmNyZWF0ZU1vdW50UmVuZGVyZXIob3B0aW9ucyk7XG4gICAgICBjYXNlIEVuenltZUFkYXB0ZXIuTU9ERVMuU0hBTExPVzogcmV0dXJuIHRoaXMuY3JlYXRlU2hhbGxvd1JlbmRlcmVyKG9wdGlvbnMpO1xuICAgICAgY2FzZSBFbnp5bWVBZGFwdGVyLk1PREVTLlNUUklORzogcmV0dXJuIHRoaXMuY3JlYXRlU3RyaW5nUmVuZGVyZXIob3B0aW9ucyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVuenltZSBJbnRlcm5hbCBFcnJvcjogVW5yZWNvZ25pemVkIG1vZGU6ICR7b3B0aW9ucy5tb2RlfWApO1xuICAgIH1cbiAgfVxuXG4gIHdyYXAoZWxlbWVudCkge1xuICAgIHJldHVybiB3cmFwKGVsZW1lbnQpO1xuICB9XG5cbiAgLy8gY29udmVydHMgYW4gUlNUTm9kZSB0byB0aGUgY29ycmVzcG9uZGluZyBKU1ggUHJhZ21hIEVsZW1lbnQuIFRoaXMgd2lsbCBiZSBuZWVkZWRcbiAgLy8gaW4gb3JkZXIgdG8gaW1wbGVtZW50IHRoZSBgV3JhcHBlci5tb3VudCgpYCBhbmQgYFdyYXBwZXIuc2hhbGxvdygpYCBtZXRob2RzLCBidXQgc2hvdWxkXG4gIC8vIGJlIHByZXR0eSBzdHJhaWdodGZvcndhcmQgZm9yIHBlb3BsZSB0byBpbXBsZW1lbnQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzLCBuby11bnVzZWQtdmFyc1xuICBub2RlVG9FbGVtZW50KG5vZGUpIHtcbiAgICBpZiAoIW5vZGUgfHwgdHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChub2RlLnR5cGUsIHByb3BzV2l0aEtleXNBbmRSZWYobm9kZSkpO1xuICB9XG5cbiAgZWxlbWVudFRvTm9kZShlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnRUb1RyZWUoZWxlbWVudCk7XG4gIH1cblxuICBub2RlVG9Ib3N0Tm9kZShub2RlLCBzdXBwb3J0c0FycmF5ID0gZmFsc2UpIHtcbiAgICBjb25zdCBub2RlcyA9IG5vZGVUb0hvc3ROb2RlKG5vZGUpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGVzKSAmJiAhc3VwcG9ydHNBcnJheSkge1xuICAgICAgcmV0dXJuIG5vZGVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG4gIH1cblxuICBkaXNwbGF5TmFtZU9mTm9kZShub2RlKSB7XG4gICAgaWYgKCFub2RlKSByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IHsgdHlwZSwgJCR0eXBlb2YgfSA9IG5vZGU7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lc0J5VHlwZVt0eXBlIHx8ICQkdHlwZW9mXSB8fCBkaXNwbGF5TmFtZU9mTm9kZShub2RlKTtcbiAgfVxuXG4gIGlzVmFsaWRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gaXNFbGVtZW50KGVsZW1lbnQpO1xuICB9XG5cbiAgaXNWYWxpZEVsZW1lbnRUeXBlKG9iamVjdCkge1xuICAgIHJldHVybiBpc1ZhbGlkRWxlbWVudFR5cGUob2JqZWN0KTtcbiAgfVxuXG4gIGlzQ3VzdG9tQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIHJldHVybiB0eXBlb2YgY29tcG9uZW50ID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgY3JlYXRlRWxlbWVudCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoLi4uYXJncyk7XG4gIH1cblxuICB3cmFwV2l0aFdyYXBwaW5nQ29tcG9uZW50KG5vZGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgUm9vdEZpbmRlcixcbiAgICAgIG5vZGU6IHdyYXBXaXRoV3JhcHBpbmdDb21wb25lbnQoUmVhY3QuY3JlYXRlRWxlbWVudCwgbm9kZSwgb3B0aW9ucyksXG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0U2l4dGVlbk9uZUFkYXB0ZXI7XG4iXX0=
//# sourceMappingURL=ReactSixteenOneAdapter.js.map